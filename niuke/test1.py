"""
给定一个数组序列, 需要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个：

区间中的最小数 * 区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列  [6 2 1]则根据上述公式, 可得到所有可以选定各个区间的计算值:
[6] = 6 * 6 = 36;

[2] = 2 * 2 = 4;

[1] = 1 * 1 = 1;

[6,2] = 2 * 8 = 16;

[2,1] = 1 * 3 = 3;

[6, 2, 1] = 1 * 9 = 9;

从上述计算可见选定区间 [6] ，计算值为 36， 则程序输出为 36。
区间内的所有数字都在[0, 100]的范围内;

输入描述:
第一行输入数组序列长度n，第二行输入数组序列。
对于 50%的数据,  1 <= n <= 10000;
对于 100%的数据, 1 <= n <= 500000;

输出描述:
输出数组经过计算后的最大值。

输入例子1:
3
6 2 1

输出例子1:
36
"""

# 暴力法居然通过了
# 主要是维护一个以当前值为最小值的最大区间，因为区间最小值乘与一个大的数结果也较大，故只需找到最长区间即可

n = int(input())

ai = list(map(int, input().split()))

# 把每个位置加和先存起来，后边根据区间算加和
sum_ai = [0]
for i in range(n):
    sum_ai.append(ai[i]+sum_ai[i])

# 每个位置对应的以此位置值为最小值的区间左右值
dp = [[i, i] for i in range(n)]

for i in range(n):

    # 为0时就不用搜索了，很关键
    if ai[i] == 0:
        continue

    # 左右值可以通过前边计算的减小搜索范围
    lr, rr = dp[i]

    while True:
        if rr + 1 < n and ai[rr+1] >= ai[i]:
            rr += 1

            # 如果搜到一个相同值，则认为这两个位置区间一样，我认为也很关键
            if ai[rr] == ai[i]:
                dp[rr] = dp[i]

        elif lr - 1 >= 0 and ai[lr-1] >= ai[i]:
            lr -= 1
        else:
            break

    # 更新dp值
    dp[i][0], dp[i][1] = [lr, rr]

    # 同时更新搜到最远处的下一个位置的左值，这也能极大减小搜索范围
    if rr + 1 < n:
        dp[rr+1][0] = lr

print(max([ai[i]*(sum_ai[v[1]+1]-sum_ai[v[0]]) for i, v in enumerate(dp) if ai[i]]))
